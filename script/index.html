<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

<div id="selector2">
  <select>
    <option value="0">test1</option>
    <option value="1">test2</option>
    <option value="2">test3</option>
  </select>
</div>

<script>
  
  /* 
  split()
  split은 문자열을 분활하는 메서드...
  쉼표를 기준으로 문자열을 분활
   */
  
  var jbString = 'a,b,c,d,e,f,g';
  var jbSplit = jbString.split(',');
  for (var i in jbSplit){
  	document.write('<p>' + jbSplit[i] + '</p>');
  }
  
  
  var a = 1;
  
  function myFunction() {
  	console.log(a); // 1
    
    var b = 2;
    
    if(true){
    	var c = 3;
    	console.log(b);
    }
    
    console.log(c);
    
  }
  myFunction();
  // 자바스크립트에서 if문 밖에서도 변수 c에 접근 가능
  // 다른언어에서는 x..
  // let 키워드로 선언한 변수를 블록 스코프라고함
  
  
  // 이러한 블록스코프 변수를 생성하기 위해 ES6에서는 let 키워드가 탄생
  // 블록 안에서 선언하면 자신을 정의한 블록또는 하위 블록에서만 접근이 가능하며 블록밖에서 사용X
  // 선언된 블록안에서만 접근할 수 있다. (함수 밖에서 선언하면 전역, 블록안에서 선언하면 블록밖에서는 접근할 수 없다.)


  let d = 4;
  function myFunction2(){
  	console.log(d);
  	
  	let e = 5;
  	
  	if(true) {
  		console.log(e);
    }

  }
  myFunction2();
  // f 의 변수값을 찾을 수 없음

  // let에서 var와 달라진 부분
  // 기존 var로 선언한 변수를 다시 var로 선언하면 ? 덮어씌어진다.
  var g = 0;
  var g = 1;
  console.log(g);



  // concat
  // 인자로 주어진 배열이나 값들을 기존 배열에 합쳐서 새 배열을 return
  var people1 = [{name:'이름1'}, {name:'이름2'}];
  var people2 = [{name:'이름3'}, {name:'이름4'}];

  people1.concat(people2).forEach(function(person){
    console.log(person.name); // 이름1, 이름2, 이름3, 이름4
  });

  // string 객체나 Number 객체가 아닌 문자열과 수의 경우, 새 배열에 문자열과 수의 "값"을 복사
  // 하기 코드에서 'power'는 b에만 영향
  var ca1 = [1, 2, 3];
  var ca2 = [4, 5, {name:'그림'}];
  var ca3 = ca1.concat(ca2);

  ca2[0] = '그림2';
  ca2[2].name = '그림3';
  console.log(ca2);
  console.log(ca3);



  // join
  // 배열의 모든 요소를 연결해 하나의 문자열 만듬
  // 인자로 특정문자열을 전달하면, 특정 문자열로 구분자로 요소들을 연결
  // 배열 요소값이 null 이거나 undefined일 경우 빈 문자열을 return

  var names = ['Shane', 'Alan', 'Osbourne'];

  // 보통의 방식
  console.log(names[0] + ' ' + names[1] + ' ' + names[2]);

  // join 방식
  console.log(names.join(' ')); // Shane Alan Osbourne
  console.log(names.join('-')); // Shane-Alan-Osbourne
  console.log(names.join()); // Shane,Alan,Osbourne 디폴트 콤마(,)



  // indexOf
  // 배열에서 지정된 요소를 찾을 수 있는 인덱스를 반환하고
  // 없으면 -1을 반환
  // === (strict Equality Comparison Algorithm) 자료형 일치여부까지 비교

  var family = ['Shane', 'Sally', 'Isaac'];
  console.log(family.indexOf('Isaac')); // 2
  console.log(family.indexOf('Kittie')); // -1

  var kittieExists = family.indexOf('Kittie') > -1 // false
  if (!kittieExists) {
    family.push('Kittie');
  }
  console.log(family); // ["Shane", "Sally", "Isaac", "Kittie"]

  console.log(family.indexOf('Sally',2)); // -1
  console.log(family.indexOf('Sally',1)); // 1
  //strict 비교
  var numberExample = [1, 2, 3];
  console.log(numberExample.indexOf("2")) // -1
  console.log(numberExample.indexOf(2)); // 1

  // 요소의 모든 항목 찾기
  var indices = [];
  var array = ["a", "b", "a", "c", "a", "d"];
  var element = "a";
  // 1. MDN 방법
  var idx = array.indexOf(element);
  while (idx != -1){
    indices.push(idx);
    idx = array.indexOf(element, idx + 1);
  }
  // 2. 다른방법
  array.forEach(function(v,i){
    if (v === element) {
      indices.push(i);
    }
  });
  console.log(indices);



  // slice
  // 배열을 전체 혹은 부분 복지(clone)할때
  // 인자를 두개 받는다. 시작 index(포함) 와 끝 index(비포함)
  var items = [1, 2, 3, 4, 5];
  var copy = items.slice();

  copy[0] = 100;
  console.log(items);  // [1, 2, 3, 4, 5]
  console.log(copy); // [100, 2, 3, 4, 5]

  var copy2 = items.slice(2, 3); // [3]
  var copy3 = items.slice(2); // [3, 4, 5]
  var copy4 = items.slice(-2); // [4, 5]
  var copy5 = items.slice(1, -1); // [2, 3, 4]



  // map
  // 배열.map((요소, 인덱스, 배열) = > {return 요소});
  let data = [1, 2, 3, 4, 5]

  // forEach 를 사용해서 원소의 값들을 각각 3씩 증가시키기
  let result = [];
  data.forEach(x => {result.push(x + 3)});
  console.log(result);

  // map을 사용하여 원소의 값들을 각각 4씩 증가시키기
  let result2 = data.map(v => {return v + 4});
  console.log(result2);



  // splice
  //기존 요소를 제거하거나 새 요소를 추가하여 배열의 내용을 변경
  // start : 배열의 변경을 시작하는 인덱스
  // deleteCount : 배열에서 제거를 할 요소의 수
  // itemN : 배열에 추가될 요소, 리턴 값 : 삭제된 요소들의 배열이 리턴

  // array.splice(start, deleteCount [, item1[, item2[, ...]]])
  var myFish = ['angel1', 'clown', 'mandarin', 'surgeon'];

  // 배열의 인덱스 2부터 1개를 제거
  var removed = myFish.splice(2, 1);
  // myFish is ['angel', 'clown', 'surgeon']
  // removed is ['mandarin']

  // 배열의 인덱스부터 1개를 제거, 그리고 그 자리에 'trumpet'을 삽입
  removed = myFish.splice(1, 1, 'trumpet');
  // myFish is ['angel', 'trumpet', 'surgeon']
  // removed is ['clown']

  // 배열의 인덱스부터 1개를 제거, 그리고 그자리에 'trumpet'을 삽입
  removed = myFish.splice(1, 1, 'trumpet11');
  //console.log(removed); // ["trumpet]
  //console.log(myFish); // ["angel1", "trumpet11", "surgeon"]

  // 배열의 인덱스 0부터 2개를 제거, 그리고 그 자리에 'parrot', 'anemone' 를 삽입
  removed = myFish.splice(0, 2, 'parrot', 'anemone');
  // console.log(myFish); // ["parrot", "anemone", "surgeon"]
  // console.log(removed); // ["angel1", "trumpet11"]

  // 배열의 인덱스 2부터 뒤에 있는 모든 요소를 제거
  removed = myFish.splice(2, Number.MAX_VALUE);
  // console.log(myFish) //["parrot", "anemone"]
  // console.log(removed); // ["surgeon"]



  // sort
  // 배열의 요소를 적절한 위치에 정렬하고 배열을 반환
  var items2 = ['Shane', 'Sally', 'Isaac'];
  items2.sort();
  // console.log(items2); // ['Isaac', 'Sally', 'Shane']

  var items3 = [10, 30, 3, 20];
  items3.sort();
  console.log(items3); // [10, 20, 3, 30]

  // 오름차순
  items3.sort( (a,b) => a - b);
  console.log(items3); // [3, 10, 20, 30]

  // 내림차순
  items3.sort( (a, b) => b - a );
  console.log(items3); // [30, 20, 10, 3]

  // 이름의 길이순으로 정렬하게
  var names2 = ['Kittie', 'John', 'Sally', 'Einstein'];
  names2.sort( (a, b) => b.length - a.length  );
  console.log(names2); // ["Einstein", "Kittie", "Sally", "John"]

  // push
  // 배열의 끝에 하나 또는 그 이상의 엘리먼트를 추가하고 배열의 변경된 길이(length)를 return
  // 비슷한 형태의 메소드로는 pop, shift, unshift 가 있고, 자료구조인 Queue나 stack을 구현할 때 사용
  // 일반적인 pop() 메서드 활용
  const pets = ['Cat', 'Dog'];
  pets.push('Hamster');
  pets.push('Horse');
  console.log(pets); // ['Cat', 'Dog', 'Hamster', 'Horse'];
  pets.push('Lion', 'Tiger');
  console.log(pets); // ['Cat', 'Dog', 'Hamster', 'Horse', 'Lion', 'Tiger'];

  // 함수 메서드 apply를 확용한 push 사용법 : 배열에 배열을 더할 수 있다.
  // 그냥 push하면 ,인자로 넘긴 배열이 nested array로 삽입됨.
  var vegetables = ['당근', '감자'];
  var moreVege = ['샐러리', '홍당무'];
  // apply를 사용
  Array.prototype.push.apply(vegetables, moreVege);
  console.log(vegetables); // ["당근", "감자", "샐러리", "홍당무"]

  // 주의해야할 문법 : nested array
  var languages = ['Node', 'Ruby'];
  var studying = ['Python', 'Sass'];
  languages.push(studying);
  console.log(languages); // ["Node", "Ruby", ["Python", "Sass"]]

  // pop : 배열에서 마지막 요소를 제거하고 그 요소를 반환 : 빈 배열에 pop() 호출하면 undefined
  // shift : 배열에서 첫번째 요소를 제거하고, 제거된 요소를 반환
  // unshift : 하나 또는 그 이상의 요소를 배열의 시작점에서 추가하고 배열의 길이를(length) 반환

  var myFish = ['angel', 'clown', 'mandarin'];
  var poped = myFish.pop();
  console.log(poped); // mandarin

  var myFruit = ['berry', 'banana', 'apple', 'choco'];
  var shifted = myFruit.shift();
  console.log(shifted); // berry

  var arr = [1, 2];
  var newLength = arr.unshift(0);
  console.log(newLength); // 3
  console.log(arr); // [0, 1, 2]

  newLength = arr.unshift(-2, -1);
  console.log(arr); // [-2, -1, 0, 1, 2]
  console.log(newLength); // 5

  arr.unshift([-3]);
  console.log(arr); // [ [-3], -2, -1, 0, 1, 2]

  // find, findIndex(ES6)
  // find : 제공된 테스트 함수를 만족하는 배열의 첫 번째 요소를 반환
  // findIndex : 제공된 테스트 함수를 만족하는 배열의 첫 번째 요소에 대한 인덱스를 반환


  // reduce
  // 배열.reduce((누적값, 현잿값, 인덱스, 요소) => { return 결과 }, 초깃값);
  const oneTwoThree = [1, 2, 3, 4];
  result4 = oneTwoThree.reduce((acc, cur, i) => {
    console.log(acc, cur, i);
    return acc + cur;
  }, 0); // 초기값 0 을 적어주지 않으면 자동으로 초기값이 0번째 인덱스의 값이 된다.
  // 0 1 0
  // 1 2 1
  // 3 3 2
  // 6 4 3
 console.log(result4); // 10

  // reduceRight는 reduce와 동작은 같지만 요소 순회를 오른쪽에서 왼쪽
  result5 = oneTwoThree.reduceRight((acc, cur, i) =>{
    console.log(acc,cur,i);
    return acc + cur;
  },0);
  // 0 4 3
  // 4 3 2
  // 7 2 1
  // 9 1 0
  console.log(result5); // 10

  // reduce vs map
  result6 = oneTwoThree.reduce((acc, cur) => {
    acc.push(cur % 2 ? '홀수' : '짝수');
    return acc;
  }, []);
  console.log(result6); // ["홀수", "짝수", "홀수", "짝수"]

  // 홀수만 필터링
  result7 = oneTwoThree.reduce((acc, cur) => {
    if (cur % 2) acc.push(cur);
    return acc;
  }, []);
  result7; // [1, 3]



  // css 관련 js

  document.querySelector('#selector2').style.background = 'black';
  document.querySelector('#selector2').style.border = '2px solid #f00';




 /*
  css 관련 js https://www.zerocho.com/category/JavaScript/post/5aa23cd4e70ee8001bc60b9a
  출처 https://www.zerocho.com/category/JavaScript/post/5acafb05f24445001b8d796d
  출처 https://medium.com/@hongkevin/js-4-array-%EB%A9%94%EC%84%9C%EB%93%9C%EB%93%A4-concat-join-indexof-slice-sort-push-4eec70d564e7
  출처 https://medium.com/@hongkevin/js-3-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%84%9C%EB%93%9C-reduce-100-%ED%99%9C%EC%9A%A9%EB%B2%95-feat-egghead-io-97c679857ece
  */
</script>



</body>
</html>